package{   	import flash.display.*;   	import flash.events.*;	import flash.text.*;	import flash.net.*;		import flash.media.*;	import flash.media.Sound;	import flash.utils.*;	import flash.net.URLRequest;		import fl.controls.Button;	import fl.controls.Slider;	import fl.controls.List;	import fl.controls.Label;		import fl.events.SliderEvent;	import fl.data.DataProvider;		import org.as3wavsound.WavSound;	import org.bytearray.micrecorder.MicRecorder;	import org.bytearray.micrecorder.encoder.WaveEncoder;	import org.bytearray.micrecorder.events.RecordingEvent;		import com.noteflight.standingwave3.elements.*;	import com.noteflight.standingwave3.filters.*;	import com.noteflight.standingwave3.formats.*;	import com.noteflight.standingwave3.generators.*;	import com.noteflight.standingwave3.modulation.*;	import com.noteflight.standingwave3.output.*;	import com.noteflight.standingwave3.performance.*;	import com.noteflight.standingwave3.sources.*;	import com.noteflight.standingwave3.utils.*;			import com.greensock.*;		import fr.kikko.lab.ShineMP3Encoder;	/*********************** CLASS ****************************/	public class VOCWordToYourMp3 extends MovieClip {				// getting sessionID from PHP:		public var sessionID:String =LoaderInfo(root.loaderInfo).parameters.sessionID;		// mic vars		public var recorder:MicRecorder = new MicRecorder(new WaveEncoder());			private var recording:Boolean = false;				// SW3 vars		//public var player:AudioPlayer = new AudioPlayer()				// mp3 vars		private var mp3Encoder:ShineMP3Encoder;					private var myWavData:ByteArray = new ByteArray()		private var myWavFile:ByteArray = new ByteArray()				// UI vars		//public var wavbtn:Button				// Sine vars		private var speedX:Number = 1;		private var speedAngle:Number = 0.3;		private var amplitude:Number = 45;		private var angle:Number = 0;		private var xpos:Number = 0;		private var ypos:Number = 0;				private var centerY:Number = 350;				// Timer function for recording act (every 1000 Milliseconds, 120s = 2 Minutes):		public var minuteTimer:Timer = new Timer(1000, 120); 		public var maxTimeinSec:Number = 120;			public var remainingSec:Number = 0;		public var addingZero:String = '0';						// Timer function for saving mp3 file first and then start listening to it only:		public var delayTimer:Timer = new Timer(1000, 3); 				// Flag:		public var hasRecorded:Boolean = false;				// URL vars - development:			public var projectPath:String=LoaderInfo(root.loaderInfo).parameters.projectPath;				private var savingPath:String=projectPath+'assets/recorder/audiofile_handler.php';				private var continuePath:String=projectPath+'upload';				private var reopenPath:String=projectPath+'upload_audiofile';		private var audiotempfilePath:String=projectPath+'audiotemp/';		// Timer for audio slider when playing audio file:			var tact = new Timer(1000,0);						/********** CONSTRUCTOR ***********/		public function VOCWordToYourMp3()		{				btnrec.addEventListener(MouseEvent.CLICK, onBtnClick)			btnrec.addEventListener(MouseEvent.ROLL_OVER, onBtnRoll)			btnrec.addEventListener(MouseEvent.ROLL_OUT, onBtnRoll)						btnrec.buttonMode = true;			btnrec.useHandCursor = true;			statustxt.text = "click on red dot to start recording \n赤いボタンを押すと録音が始まります。";							recorder.addEventListener(RecordingEvent.RECORDING, onRecording)			recorder.addEventListener(Event.COMPLETE, onRecordComplete)						//player.addEventListener(Event.COMPLETE, onPlayComplete)						//wavbtn.addEventListener(MouseEvent.CLICK, onWavtoMp3Save)						// Micro Soundmeter			soundMeter.scaleX = 0.05					            minuteTimer.addEventListener(TimerEvent.TIMER, onTick);             minuteTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onTimerComplete); 					}						public function onBtnClick(e:MouseEvent)		{		startRecording()		}				public function onBtnRoll(e:MouseEvent)			{								}						public function startRecording()		{						if (!recording) 			{				trace("recordstart");				soundMeter.alpha = 100;				mic_text_inst.alpha = 100;				recorder.record()				minuteTimer.start();				//wavbtn.enabled = false;											} else if (recording) {				trace("recordstop");								btnrec.removeEventListener(MouseEvent.CLICK, onBtnClick)				btnrec.gotoAndStop('stopped');				btnrec.buttonMode = false;				btnrec.useHandCursor = false;				// this fucking property seems not working:				btnrec.alpha = 20;								hasRecorded = true;								recorder.stop()				recording = false;								minuteTimer.stop();				minuteTimer.reset();				remainingSec = 00;				addingZero = '0';									soundMeter.alpha = 20;				mic_text_inst.alpha = 20;			}		}				public function onRecording(e:RecordingEvent)		{			     			statustxt.text='your voice is being recorded - time left: '+"\n"+'ただいま録音中です。残り時間:' +"\n"+ Math.floor((maxTimeinSec - minuteTimer.currentCount)/60) + ':'+							 addingZero + (remainingSec) ;								// Roter Knopf beginnt zu blinken:			btnrec.play();				// SoundMeter reacting:			var al:Number = recorder.microphone.activityLevel;			TweenMax.to(soundMeter, .1, {scaleX:(al * .003)+0.05, onUpdate:onActivitylevelUpdate, onUpdateParams:[al]});//, onUpdateParams:[al]})						if (!recording) recording = true;		}					public function onActivitylevelUpdate(al)		{			// draw a cool sine wave!			xpos += speedX;			ypos = centerY + Math.sin(angle) * amplitude * ((al > 20)? al / 100 : 1)			angle += speedAngle;			graphics.lineTo(xpos,ypos)		}				private function onTick(event:TimerEvent):void 		{			if(remainingSec == 00 || remainingSec == 0) {remainingSec = 60}				remainingSec = remainingSec -1;		 	if(remainingSec < 10) {addingZero = "0"} else {addingZero = ''}			}				private function onTimerComplete(event:TimerEvent):void 		{ 		  	trace("recordstop");			hasRecorded = true;						soundMeter.alpha = 0;						btnrec.gotoAndStop('stopped');			btnrec.useHandCursor = false;						minuteTimer.stop();			minuteTimer.reset();						remainingSec = 00;			addingZero = '0';					if (recording) {				recorder.stop()				recording = false					}					}				private function onRecordComplete(e:Event):void 		{					trace("onRecordComplete");			soundMeter.scaleX = 0						recording = false;						statustxt.text = "recording complete // 録音が完了しました。"							var src = WaveFile.createSample(recorder.output) // this is fine						// I think im not clearing out the old audio properly here somehow...			var sequence = new ListPerformance()			sequence.addSourceAt(0, src)						var ap = new AudioPerformer(sequence, new AudioDescriptor())						renderWav(ap, true);		}				private function renderWav(src, convertToMp3 = false)		{				var innerTimer = new Timer(10,0)			var framesPerChunk:uint = 8192;			innerTimer.addEventListener(TimerEvent.TIMER, handleRenderTimer)			innerTimer.start()									function handleRenderTimer(e:TimerEvent)			{   trace("handleRenderTime and a random number: " + Math.random());				src.getSample(framesPerChunk).writeWavBytes(myWavData)								var m = Math.min(src.frameCount, src.position + framesPerChunk)				var n = Math.max(0, m - src.position)								if (n == 0)				{   					if (src.position > 0) finishRender() else trace("cancel rendering")				} else {					statustxt.text = "please wait - rendering audio: \n少々お待ちください。\n内容をレンダリングしています。\n"+ Math.floor(src.position * 100 / src.frameCount) + "%";				}			}										function finishRender()			{				innerTimer.stop()				statustxt.text = "please wait - finished audio render \n少々お待ちください。\nレンダリングが完了しました。"				WaveFile.writeBytesToWavFile(myWavFile, myWavData, 44100, 2, 16)											if (!convertToMp3)				{					trace('Error in function finishRender');				} else {					makeIntoMp3(myWavFile)				}			}						}				private function makeIntoMp3(wav)		{			wav.position = 0						mp3Encoder = new ShineMP3Encoder(wav);			mp3Encoder.addEventListener(Event.COMPLETE, mp3EncodeComplete);			mp3Encoder.addEventListener(ProgressEvent.PROGRESS, mp3EncodeProgress);			//mp3Encoder.addEventListener(ErrorEvent.ERROR, mp3EncodeError);			mp3Encoder.start();				function mp3EncodeProgress(e:ProgressEvent):void 			{				statustxt.text = "please wait encoding file: \n少々お待ちください。\nファイルを作成中です: \n" + e.bytesLoaded + "%"			}						function mp3EncodeComplete(e: Event) : void 			{				statustxt.text = "please wait saving audio file \n少々お待ちください。\nファイルを保存中です。"				//wavbtn.enabled = true;					//wavbtn.visible = true;				onWavtoMp3Save();			}							}				function onWavtoMp3Save():void		{						// WRITE ID3 TAGS			var sba:ByteArray = mp3Encoder.mp3Data;			sba.position =  sba.length - 128			sba.writeMultiByte("TAG", "iso-8859-1");			sba.writeMultiByte("Title and sessiondID: "+ sessionID +String.fromCharCode(0), "iso-8859-1");	// Title			sba.writeMultiByte("Artist                 "+String.fromCharCode(0), "iso-8859-1");	// Artist						sba.writeMultiByte("Album  "+String.fromCharCode(0), "iso-8859-1");	// Album					sba.writeMultiByte("2012" + String.fromCharCode(0), "iso-8859-1");							// Year			sba.writeMultiByte("www.namidad.com         " + String.fromCharCode(0), "iso-8859-1");// comments			sba.writeByte(57);																					var request:URLRequest = new URLRequest(savingPath + '?sessionID='+sessionID+'&do=save');			var loader: URLLoader = new URLLoader();			request.contentType = 'application/octet-stream';			request.method = URLRequestMethod.POST;			request.data = '';			request.data = sba;			loader.load( request ); 			trace("saved as mp3 file");					delayTimer.addEventListener(TimerEvent.TIMER_COMPLETE, initialize_player); 			delayTimer.start();		}						private function onPlayComplete(e:Event)		{			statustxt.text = "playing complete \n再生を完了しました。";				trace("playing complete");		}								private function initialize_player(event:TimerEvent):void  		{			statustxt.text = "done \n終了です。";						trace("function intitialize_player() called");						var mp3filename:String = audiotempfilePath+ sessionID + ".mp3";			var music:Sound = new Sound(new URLRequest(mp3filename));			var sc:SoundChannel = music.play();			var currentPos:Number = sc.position;			sc.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);			var isPlaying:Boolean = true;						function soundCompleteHandler(e:Event):void {				finishedListening();        	}						function finishedListening() {				trace("Scound complete and a random number: " + Math.random());				isPlaying = false;				play_control_inst.gotoAndStop('replay');								sc = music.play(0);				sc.stop();				mySlider.value = 0;				tact.stop();				currentPos = 0;			}						initializeSlider();						play_control_inst.gotoAndPlay('listening');			play_control_inst.alpha = 100;			play_control_inst.buttonMode = true;			play_control_inst.useHandCursor = true;			play_control_inst.addEventListener(MouseEvent.CLICK,playMusic);						submit_btn_inst.alpha = 100;			submit_btn_inst.buttonMode = true;			submit_btn_inst.useHandCursor = true;			submit_btn_inst.addEventListener(MouseEvent.CLICK, submit_register)					// RETRY BUTTON ACTIVATING			repeat_btn_inst.buttonMode = true;			repeat_btn_inst.useHandCursor = true;			repeat_btn_inst.alpha = 100;			repeat_btn_inst.addEventListener(MouseEvent.CLICK, retryRecord)								function retryRecord(e:MouseEvent) {				trace("retry clicked");				navigateToURL(new URLRequest(reopenPath),'_self');			}							function submit_register(e:MouseEvent) {				trace("submit_register request: " + continuePath+'/'+ Math.floor(music.length));				navigateToURL(new URLRequest(continuePath+'/'+ Math.floor(music.length)),'_self');							}					function playMusic(e:Event):void {								trace("play button geklickt" + Math.random());				if (!isPlaying) {					trace("playing" + Math.random());					tact.start();					play_control_inst.gotoAndPlay('listening');					isPlaying = true;					sc = music.play(currentPos);					sc.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);					trace("The playing music position in Milliseconds: "+sc.position);				} else {					tact.stop();					currentPos = sc.position;					trace("stopped" + Math.random());					play_control_inst.gotoAndStop('paused');					isPlaying = false;					sc.stop();				}							}						function initializeSlider():void {				endline_slider_inst.alpha = 100;				mySlider.alpha = 100;				mySlider.minimum = 0;				mySlider.maximum = 100;				mySlider.liveDragging = true;				mySlider.snapInterval = 2;				mySlider.addEventListener(SliderEvent.THUMB_PRESS, thumbPressHandler);				mySlider.addEventListener(SliderEvent.THUMB_RELEASE, thumbReleaseHandler);							addChild(mySlider);											// Make hand on the black dot:				var mc = mySlider.getChildAt(1); // it is a drag button.				mc.buttonMode = true;				mc.useHandCursor = true; 											tact.addEventListener(TimerEvent.TIMER, timerHandler);				tact.start();							    var hasEnded:int = 0;												function timerHandler(event:TimerEvent):void {					trace("sc.position is now: " +sc.position + ' and music length: '+ music.length);					mySlider.value = Math.ceil(100 * (sc.position / music.length));										var audioFileMin:int = 0;					var audioFileSec:int = sc.position/1000 - (audioFileMin*60);					var leadingZero:String = '';					if (audioFileSec<10) { leadingZero = '0'} else {leadingZero = ''}					timedisplay.text = String(audioFileMin) + ':' +leadingZero+ String(audioFileSec);										if(100 * (sc.position / music.length) >= 99) {						hasEnded = hasEnded + 1;					}					trace("hasEnded" + hasEnded);					if (hasEnded >=2) {						finishedListening();						hasEnded = 0;					}				}								function thumbPressHandler(event:SliderEvent):void {					tact.stop();						sc.stop();				}								function thumbReleaseHandler(event:SliderEvent):void {					sc = music.play(music.length *event.value / 100 );					tact.start();						play_control_inst.gotoAndPlay('listening');				}			} // END function InitializeSlider()		}	// END function initialize_player()									} // Class} // Package